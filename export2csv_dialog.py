# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Export2csvDialog
                                 A QGIS plugin
 export coordinates to csv
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-02-28
        git sha              : $Format:%H$
        copyright            : (C) 2022 by axinav
        email                : axinav
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import csv

from qgis.core import *
from qgis.gui import *
from qgis.utils import *

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QObject,  QSettings

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'export2csv_dialog_base.ui'))


class Export2csvDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(Export2csvDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface
        self.pointLayerCBox.setFilters(QgsMapLayerProxyModel.Filter.PointLayer)
        self.pointFieldCBox.setLayer(self.pointLayerCBox.currentLayer())
        self.borderDescCBox.setFilters(QgsMapLayerProxyModel.Filter.PolygonLayer)
        self.nodebrowse.clicked.connect(self.browse_nodes)
        #QObject.connect(self.nodebrowse, SIGNAL("clicked()"), self.browse_nodes)
        self.pointLayerCBox.currentIndexChanged.connect(self.pointLayerChanged)
        #QObject.connect(self.pointLayerCBox, SIGNAL("currentIndexChanged(int)"), self.pointLayerChanged)
        #QObject.connect(self.pointLayerCBox, SIGNAL("layerChanged(QgsMapLayer)"),self.pointFieldCBox, SLOT("setLayer(QgsMapLayer)"))
        self.buttonBox.accepted.connect(self.run)
        #QObject.connect(self.buttonBox, QtCore.SIGNAL("accepted()"), self.run)

    def pointLayerChanged(self):
        self.pointFieldCBox.setLayer(self.pointLayerCBox.currentLayer())
    def browse_nodes(self):
        newname = QtWidgets.QFileDialog.getSaveFileName(self, "Output Nodes CSV File",
                                                    self.nodefilename.displayText(), "CSV File (*.csv *.txt)")

        if newname != None:
            self.nodefilename.setText(newname[0])

    def run(self):
        delimiter = ","

        lineterminator = "\r\n"


        nodefilename = self.nodefilename.displayText()


        message = self.geometry_export_to_csv(self.iface,  nodefilename, delimiter, lineterminator)
        if message != None:
            QMessageBox.critical(self.iface.mainWindow(), "Geometry Export", message)

    def freePntsNumber(self):
        layer=self.pointLayerCBox.currentLayer()
        self.pntsnumber=[]
        for feature_index, feature in enumerate(layer.dataProvider().getFeatures()):
            self.pntsnumber.append(feature.attribute(self.pointFieldCBox.currentField()))


    def geometry_export_to_csv(self,qgis, node_filename,  field_delimiter,line_terminator):
        self.freePntsNumber()
        layer = self.sourceLayerCBox.currentLayer()

        if (layer == None) or (layer.type() != QgsMapLayer.VectorLayer):
            return "Invalid Vector Layer " + layer.name()

        node_header = ["shapeid", "Номер точки", "X", "Y"]
        if (layer.geometryType() != QgsWkbTypes.Point):
            node_header.append('Длина линии')

        if self.checkBox.isChecked():
            node_header.append('Описание границы')


        try:
            nodefile = open(node_filename, 'w', encoding='utf-8')
        except:
            return "Failure opening " + node_filename

        node_writer = csv.writer(nodefile, delimiter=field_delimiter, lineterminator=line_terminator, quoting=csv.QUOTE_NONNUMERIC)

        # Encoding is forced to UTF-8 because CSV writer doesn't support Unicode
        node_writer.writerow( node_header)



        # Iterate through each feature in the source layer

        # feature = QgsFeature()
        # layer.dataProvider().select(layer.dataProvider().attributeIndexes())
        # layer.dataProvider().rewind()
        # while layer.dataProvider().nextFeature(feature):

        feature_type = ""
        feature_count = layer.dataProvider().featureCount()
        for feature_index, feature in enumerate(layer.dataProvider().getFeatures()):
            feature_type = unicode(feature.geometry().wkbType())
            # shapeid = unicode(feature.id()).strip()
            # print "Feature " + str(feature_index) + " = " + feature_type

            if (feature_index % 10) == 0:
                self.mmqgis_status_message(qgis, "Exporting feature " + unicode(feature_index)+ " of " + unicode(feature_count))

            if (feature.geometry() == None):
                return "Cannot export layer with no shape data"

            elif (feature.geometry().wkbType() == QgsWkbTypes.Point) or \
                    (feature.geometry().wkbType() == QgsWkbTypes.Point25D):
                point = feature.geometry().asPoint()
                row = [unicode(feature_index), unicode(point.x()), unicode(point.y())]
                for attindex, attribute in enumerate(feature.attributes()):
                    row.append(unicode(attribute).encode("utf-8"))
                node_writer.writerow(row)

            elif (feature.geometry().wkbType() == QgsWkbTypes.MultiPoint) or \
                    (feature.geometry().wkbType() == QgsWkbTypes.MultiPoint25D):
                points = feature.geometry().asMultiPoint()
                for point_index, point in enumerate(points):
                    shape_id = unicode(feature_index) + "." + unicode(point_index)
                    row = [shape_id, unicode(point.x()), unicode(point.y())]
                    row.extend(feature.attributes())
                    node_writer.writerow([unicode(field).encode("utf-8") for field in row])

            elif (feature.geometry().wkbType() == QgsWkbTypes.LineString) or \
                    (feature.geometry().wkbType() == QgsWkbTypes.LineString25D):
                polyline = feature.geometry().asPolyline()
                pntLayer = self.pointLayerCBox.currentLayer()
                p1 = polyline[0]
                d = QgsDistanceArea()
                #d.setEllipsoidalMode(False)
                for idp, point in enumerate(polyline):
                    idpnt = idp
                    if pntLayer:
                        pntgeom = QgsGeometry.fromPointXY(point)
                        for ftr in pntLayer.dataProvider().getFeatures():
                            if ftr.geometry().isGeosEqual(pntgeom):
                                idpnt = ftr.attribute(self.pointFieldCBox.currentField())

                    if not idpnt:
                        idpnt = len(self.pntsnumber) + 1
                        self.pntsnumber.append(idpnt)
                    if idp == 0:

                        row = [feature_index, idpnt, unicode(point.y()), unicode(point.x())]
                        node_writer.writerow(row)

                    else:
                        row = [feature_index, idpnt, unicode(point.y()), unicode(point.x()),
                               unicode(round(d.measureLine(point, p1),2))]
                        node_writer.writerow(row)
                    p1 = point




            elif (feature.geometry().wkbType() == QgsWkbTypes.MultiLineString) or \
                    (feature.geometry().wkbType() == QgsWkbTypes.MultiLineString25D):
                polylines = feature.geometry().asMultiPolyline()
                pntLayer = self.pointLayerCBox.currentLayer()
                d = QgsDistanceArea()
                #d.setEllipsoidalMode(False)
                for polyline_index, polyline in enumerate(polylines):
                    shape_id = unicode(feature_index) + "." + unicode(polyline_index)
                    p1 = polyline[0]
                    for idp, point in enumerate(polyline):
                        idpnt = idp
                        if pntLayer:
                            pntgeom = QgsGeometry.fromPointXY(point)
                            for ftr in pntLayer.dataProvider().getFeatures():
                                if ftr.geometry().isGeosEqual(pntgeom):
                                    idpnt = ftr.attribute(self.pointFieldCBox.currentField())

                        if not idpnt:
                            idpnt = len(self.pntsnumber) + 1
                            self.pntsnumber.append(idpnt)
                        if idp == 0:

                            row = [shape_id, idpnt, unicode(point.y()), unicode(point.x())]
                            node_writer.writerow(row)

                        else:
                            row = [shape_id, idpnt, unicode(point.y()), unicode(point.x()),
                                   unicode(round(d.measureLine(point, p1),2))]
                            node_writer.writerow(row)
                        p1 = point




            elif (feature.geometry().wkbType() == QgsWkbTypes.Polygon) or \
                    (feature.geometry().wkbType() == QgsWkbTypes.Polygon25D):
                # The first polyline in the polygon is the outer ring
                # Subsequent polylines (if any) are inner rings (holes)
                ring_number = 0
                polygon = feature.geometry().asPolygon()
                pntLayer = self.pointLayerCBox.currentLayer()
                for polyline in polygon:
                    shape_id = unicode(feature_index)
                    if ring_number > 0:
                        shape_id = shape_id + ".ring" + unicode(ring_number)
                    ring_number = ring_number + 1
                    p1 = polyline[0]
                    d = QgsDistanceArea()
                    #d.setEllipsoidalMode(False)
                    countP = len(polyline) - 1

                    for idp, point in enumerate(polyline):
                        idpnt = None
                        if pntLayer:
                            pntgeom = QgsGeometry.fromPointXY(point)
                            for ftr in pntLayer.dataProvider().getFeatures():
                                if ftr.geometry().equals(pntgeom):
                                    idpnt = ftr.attribute(self.pointFieldCBox.currentField())
                                    print(idpnt)

                        if not idpnt:
                            idpnt=len(self.pntsnumber)+1
                            self.pntsnumber.append(idpnt)
                        if idp == 0:

                            row = [shape_id, idpnt, unicode(point.y()), unicode(point.x())]
                            node_writer.writerow(row)

                        else:
                            row = [shape_id, idpnt, unicode(point.y()), unicode(point.x()),
                                   unicode(round(d.measureLine(point, p1),2))]
                            node_writer.writerow(row)
                        p1 = point




            elif (feature.geometry().wkbType() == QgsWkbTypes.MultiPolygon) or \
                    (feature.geometry().wkbType() == QgsWkbTypes.MultiPolygon25D):
                multipolygon = feature.geometry().asMultiPolygon()
                pntLayer = self.pointLayerCBox.currentLayer()
                for polygon_index, polygon in enumerate(multipolygon):
                    ring_number = 0
                    for polyline in polygon:
                        shape_id = unicode(feature_index) + "." + unicode(polygon_index)
                        if ring_number > 0:
                            shape_id = shape_id + ".ring" + unicode(ring_number)
                        ring_number = ring_number + 1
                        p1 = polyline[0]
                        d = QgsDistanceArea()
                        #d.setEllipsoidalMode(False)
                        countP = len(polyline) - 1

                        for idp, point in enumerate(polyline):
                            idpnt = None

                            if pntLayer:
                                pntgeom = QgsGeometry.fromPointXY(point)
                                for ftr in pntLayer.dataProvider().getFeatures():
                                    if ftr.geometry().equals(pntgeom):
                                        idpnt = ftr.attribute(self.pointFieldCBox.currentField())


                            if idpnt==None:
                                idpnt = len(self.pntsnumber)+1
                                self.pntsnumber.append(idpnt)
                            if idp == 0:

                                row = [shape_id, idpnt, unicode(point.y()), unicode(point.x())]
                                node_writer.writerow(row)

                            else:
                                row = [shape_id, idpnt, unicode(point.y()), unicode(point.x()),
                                       unicode(round(d.measureLine(point, p1),2))]
                                node_writer.writerow(row)
                            p1 = point




            else:
                return "Unsupported geometry: " + unicode(feature.geometry().wkbType())

        nodefile.close()
        #del nodefile


        self.mmqgis_completion_message(qgis, unicode(feature_count) + " records exported (" + feature_type + ")")

        return None

    def mmqgis_status_message(self,qgis, message):
        qgis.mainWindow().statusBar().showMessage(message)

    def mmqgis_completion_message(self,qgis, message):
        self.mmqgis_status_message(qgis, message)
        qgis.messageBar().pushMessage(message, 0, 3)

